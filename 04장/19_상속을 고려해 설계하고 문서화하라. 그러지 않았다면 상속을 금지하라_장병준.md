# 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

### 1. 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
- Item 18 에서 본 것처럼, 클래스 API 가 자신의 다른 메서드를 호출할 수 있다. 호출되는 메서드가 재정의 기능 메서드라면 메서드의 api 설명에 적시해야한다. 더 나아가 어떤 순서로 호출되는지, 모든 상황을 문서로 남겨야 한다. 백그라운드 스레드나 정적 초기화 과정에도 호출되어 다른 영향을 끼칠 수 있으니 모두 작성하자.
- '재정의 기능'이란 public과 protected 메서드 중 final이 아닌 모든 메서드를 말한다.
- 내부 구현을 알리는 문서화 용도로 사용할 수 있는 태그는 @ImplSpec 이다.
```java
public class ExtendableClass {
    /**
     * This method can be overriden to print any message.
     *
     * @ImplSpec
     * Please use System.out.println().
     */
    public void doSomething() {
        System.out.println("hello");
    }
}
```
---
### 2. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개해야 할 수도 있다. 그리고 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.   
- 재정의를 허용할 메서드만 protected로 잘 선별해야한다. 또한 선별된 결과가 이상적인지 확인하기 위해서 상속용으로 설계한 클래스의 하위 클래스를 여러 개 만들어서 검증한다.
- 검증방법
  - 필요없는 메서드가 protected로 노출되지는 않았는지.
  - 필요한 메서드가 private로 남아있는 것은 아닌지.
---
### 3. 상속용 클래스의 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
- 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.
#### Super 클래스 (부모)
```java
public class Super {

   public Super() {
      overrideMe();
   }

   void overrideMe() {
   }
}
```
- Super 클래스는 재정의 가능한 메서드 overrideMe()를 가지고 있다.
- Super 클래스의 생성자는 overrideMe()를 호출한다.
#### Super 클래스를 상속한 Sub 클래스
```java
public class Sub extends Super{
    // 초기화 되지 않은 final 필드. 생성자에서 초기화한다.

    private final Instant instant;

    Sub() {
        // super() // 자바 default
        this.instant = Instant.now();
    }

    // 재정의 가능한 메서드. 상위 클래스의 생성자가 호출된다.
    @Override
    void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}

결과값 : null
        2023-10-13T13:06:12.837874Z
```
- Sub 클래스는 필드로 Instant를 가진다. 그런데 이 Instant는 Sub 클래스가 생성될 때 만들어진다.
- Sub 클래스가 생성될 때, super()를 통해 부모 클래스 Super가 생성된 다음에 Instant가 생성된다.
- 첫번째 실행에 null 이 되는 이유
  - Sub의 인스턴스가 생성되면서 Super의 생성자가 호출되고, 그 과정에서 overrideMe() 메서드가 호출된다. 아직 instant는 초기화되지 않은 상태이므로 Sub의 overrideMe() 메서드는 null을 출력하게 된다.
---

### 4. Cloneable / Serializable 구현 클래스의 상속
- clone(), readObject() 와 같은 경우도 생성자와 비슷한 효과를 가지고 있으므로 직접적이든 간접적이든 재정의 가능한 메서드를 호출해선 안 된다.
  - clone()는 하위 클래스의 clone() 메서드가 복제본의 상태를 올바른 상태로 수정하기 전에 재정의한 메서드를 호출한다.
    - clone()이 잘못되면 원본 객체에도 피해를 줄 수 있다.
  - readObject()는 역직렬화가 끝나기 전에 재정의한 메서드부터 호출하게 된다.
- Cloneable 이나 Serializable 인터페이스를 구현하는 클래스를 상속 가능하도록 만들면 이를 상속받는 하위의 모든 클래스들이 복제와 직렬화 기능을 고려하여 구현되어야 하기 때문에 구현이 복잡해지고 어려워진다. 따라서 이들 인터페이스를 구현하는 클래스는 상속을 막는 것이 더 적절하다고 한다.
---
### 5. 상속용으로 설계하지 않은 클래스는 상속을 금지시킨다.
- 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지도 않는다. 하지만 이러한 사실은 클래스에 변화가 생길 때마다 하위 클래스를 오동작하게 만들 수 있기 때문에 위험하다.
- 방법
  1. 가장 쉬운 방법은 final 클래스로 만들기.
  2. 모든 생성자를 private 또는 package-private으로 만들고 정적 팩토리를 제공하기.
#### 일반 클래스에서 상속을 허용하고 싶다면, 재정의 가능 메서드는 절대 사용하지 않도록 문서에 표기한다.

---
### 핵심 정리
- 상속용 메서드를 만들 때는 클래스 내부에서 스스로를 어떻게 사용하는지 문서로 남기자.
- 문서화한 것은 그 클래스가 쓰이는 한 반드시 지키자. 
  - 그렇지 않을 경우 하위 클래스의 오동작을 만들 수 있다.
- 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하자.
  - 클래스를 final로 만들거나 생성자를 모두 외부에서 접근 불가능하게 바꾸면 된다.